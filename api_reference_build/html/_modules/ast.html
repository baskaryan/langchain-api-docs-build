
<!DOCTYPE html>

<html data-content_root="" lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>ast â€” ðŸ¦œðŸ”— LangChain  documentation</title>
<script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "";
  </script>
<!-- Loaded before other Sphinx assets -->
<link href="../_static/styles/theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet"/>
<link href="../_static/styles/bootstrap.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet"/>
<link href="../_static/styles/pydata-sphinx-theme.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet"/>
<link href="../_static/vendor/fontawesome/6.5.2/css/all.min.css?digest=dfe6caa3a7d634c4db9b" rel="stylesheet"/>
<link as="font" crossorigin="" href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-solid-900.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-brands-400.woff2" rel="preload" type="font/woff2"/>
<link as="font" crossorigin="" href="../_static/vendor/fontawesome/6.5.2/webfonts/fa-regular-400.woff2" rel="preload" type="font/woff2"/>
<link href="../_static/pygments.css" rel="stylesheet" type="text/css"/>
<link href="../_static/autodoc_pydantic.css" rel="stylesheet" type="text/css"/>
<link href="../_static/copybutton.css" rel="stylesheet" type="text/css"/>
<link href="../_static/sphinx-design.4cbf315f70debaebd550c87a6162cf0f.min.css" rel="stylesheet" type="text/css"/>
<link href="../_static/css/custom.css" rel="stylesheet" type="text/css"/>
<!-- Pre-loaded scripts that we'll load fully later -->
<link as="script" href="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b" rel="preload"/>
<link as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b" rel="preload"/>
<script src="../_static/vendor/fontawesome/6.5.2/js/all.min.js?digest=dfe6caa3a7d634c4db9b"></script>
<script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
<script src="../_static/doctools.js"></script>
<script src="../_static/sphinx_highlight.js"></script>
<script src="../_static/clipboard.min.js"></script>
<script src="../_static/copybutton.js"></script>
<script src="../_static/design-tabs.js"></script>
<script>DOCUMENTATION_OPTIONS.pagename = '_modules/ast';</script>
<link href="../_static/favicon.png" rel="icon"/>
<link href="../search.html" rel="search" title="Search"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<meta content="en" name="docsearch:language"/>
<meta content="Aug 22, 2024" name="docbuild:last-update"/>
</head>
<body data-bs-root-margin="0px 0px -60%" data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-default-mode="" data-offset="180">
<div class="skip-link d-print-none" id="pst-skip-link"><a href="#main-content">Skip to main content</a></div>
<div id="pst-scroll-pixel-helper"></div>
<button class="btn rounded-pill" id="pst-back-to-top" type="button">
<i class="fa-solid fa-arrow-up"></i>Back to top</button>
<input class="sidebar-toggle" id="pst-primary-sidebar-checkbox" type="checkbox"/>
<label class="overlay overlay-primary" for="pst-primary-sidebar-checkbox"></label>
<input class="sidebar-toggle" id="pst-secondary-sidebar-checkbox" type="checkbox"/>
<label class="overlay overlay-secondary" for="pst-secondary-sidebar-checkbox"></label>
<div class="search-button__wrapper">
<div class="search-button__overlay"></div>
<div class="search-button__search-container">
<form action="../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="fa-solid fa-magnifying-glass"></i>
<input aria-label="Search" autocapitalize="off" autocomplete="off" autocorrect="off" class="form-control" id="search-input" name="q" placeholder="Search" spellcheck="false" type="search"/>
<span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
</div>
<div class="pst-async-banner-revealer d-none">
<aside aria-label="Version warning" class="d-none d-print-none" id="bd-header-version-warning"></aside>
</div>
<header class="bd-header navbar navbar-expand-lg bd-navbar d-print-none">
<div class="bd-header__inner bd-page-width">
<button aria-label="Site navigation" class="pst-navbar-icon sidebar-toggle primary-toggle">
<span class="fa-solid fa-bars"></span>
</button>
<div class="navbar-header-items__start">
<div class="navbar-item">
<a class="navbar-brand logo" href="../index.html">
<img alt="ðŸ¦œðŸ”— LangChain  documentation - Home" class="logo__image only-light" src="../_static/wordmark-api.svg"/>
<script>document.write(`<img src="../_static/wordmark-api-dark.svg" class="logo__image only-dark" alt="ðŸ¦œðŸ”— LangChain  documentation - Home"/>`);</script>
</a></div>
</div>
<div class="navbar-header-items">
<div class="me-auto navbar-header-items__center">
<div class="navbar-item">
<nav>
<ul class="bd-navbar-elements navbar-nav">
<li class="nav-item">
<a class="nav-link nav-internal" href="../reference.html">
    Reference
  </a>
</li>
<li class="nav-item">
<a class="nav-link nav-external" href="https://api.python.langchain.com/">
    Legacy reference
  </a>
</li>
</ul>
</nav></div>
</div>
<div class="navbar-header-items__end">
<div class="navbar-item navbar-persistent--container">
<form action="../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="fa-solid fa-magnifying-glass"></i>
<input aria-label="Search" autocapitalize="off" autocomplete="off" autocorrect="off" class="form-control" id="search-input" name="q" placeholder="Search" spellcheck="false" type="search"/>
<span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
</div>
<div class="navbar-item"><!-- This will display a link to LangChain docs -->
<head>
<style>
        .text-link {
            text-decoration: none; /* Remove underline */
            color: inherit;        /* Inherit color from parent element */
        }
    </style>
</head>
<body>
<a class="text-link" href="https://python.langchain.com/">Docs</a>
</body></div>
<div class="navbar-item">
<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
<div class="navbar-item"><ul aria-label="Quick Links" class="navbar-icon-links">
<li class="nav-item">
<a class="nav-link pst-navbar-icon" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://github.com/langchain-ai/langchain" rel="noopener" target="_blank" title="GitHub"><i aria-hidden="true" class="fa-brands fa-square-github fa-lg"></i>
<span class="sr-only">GitHub</span></a>
</li>
<li class="nav-item">
<a class="nav-link pst-navbar-icon" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://twitter.com/langchainai" rel="noopener" target="_blank" title="X / Twitter"><i aria-hidden="true" class="fab fa-twitter-square fa-lg"></i>
<span class="sr-only">X / Twitter</span></a>
</li>
</ul></div>
</div>
</div>
<div class="navbar-persistent--mobile">
<form action="../search.html" class="bd-search d-flex align-items-center" method="get">
<i class="fa-solid fa-magnifying-glass"></i>
<input aria-label="Search" autocapitalize="off" autocomplete="off" autocorrect="off" class="form-control" id="search-input" name="q" placeholder="Search" spellcheck="false" type="search"/>
<span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form>
</div>
</div>
</header>
<div class="bd-container">
<div class="bd-container__inner bd-page-width">
<div class="bd-sidebar-primary bd-sidebar hide-on-wide">
<div class="sidebar-header-items sidebar-primary__section">
<div class="sidebar-header-items__center">
<div class="navbar-item">
<nav>
<ul class="bd-navbar-elements navbar-nav">
<li class="nav-item">
<a class="nav-link nav-internal" href="../reference.html">
    Reference
  </a>
</li>
<li class="nav-item">
<a class="nav-link nav-external" href="https://api.python.langchain.com/">
    Legacy reference
  </a>
</li>
</ul>
</nav></div>
</div>
<div class="sidebar-header-items__end">
<div class="navbar-item"><!-- This will display a link to LangChain docs -->
<head>
<style>
        .text-link {
            text-decoration: none; /* Remove underline */
            color: inherit;        /* Inherit color from parent element */
        }
    </style>
</head>
<body>
<a class="text-link" href="https://python.langchain.com/">Docs</a>
</body></div>
<div class="navbar-item">
<script>
document.write(`
  <button class="btn btn-sm nav-link pst-navbar-icon theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="theme-switch fa-solid fa-sun fa-lg" data-mode="light"></i>
    <i class="theme-switch fa-solid fa-moon fa-lg" data-mode="dark"></i>
    <i class="theme-switch fa-solid fa-circle-half-stroke fa-lg" data-mode="auto"></i>
  </button>
`);
</script></div>
<div class="navbar-item"><ul aria-label="Quick Links" class="navbar-icon-links">
<li class="nav-item">
<a class="nav-link pst-navbar-icon" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://github.com/langchain-ai/langchain" rel="noopener" target="_blank" title="GitHub"><i aria-hidden="true" class="fa-brands fa-square-github fa-lg"></i>
<span class="sr-only">GitHub</span></a>
</li>
<li class="nav-item">
<a class="nav-link pst-navbar-icon" data-bs-placement="bottom" data-bs-toggle="tooltip" href="https://twitter.com/langchainai" rel="noopener" target="_blank" title="X / Twitter"><i aria-hidden="true" class="fab fa-twitter-square fa-lg"></i>
<span class="sr-only">X / Twitter</span></a>
</li>
</ul></div>
</div>
</div>
<div class="sidebar-primary-items__end sidebar-primary__section">
</div>
<div id="rtd-footer-container"></div>
</div>
<main class="bd-main" id="main-content" role="main">
<div class="bd-content">
<div class="bd-article-container">
<div class="bd-header-article d-print-none">
<div class="header-article-items header-article__inner">
<div class="header-article-items__start">
<div class="header-article-item">
<nav aria-label="Breadcrumb" class="d-print-none">
<ul class="bd-breadcrumbs">
<li class="breadcrumb-item breadcrumb-home">
<a aria-label="Home" class="nav-link" href="../index.html">
<i class="fa-solid fa-home"></i>
</a>
</li>
<li class="breadcrumb-item"><a class="nav-link" href="index.html">Module code</a></li>
<li aria-current="page" class="breadcrumb-item active">ast</li>
</ul>
</nav>
</div>
</div>
</div>
</div>
<div id="searchbox"></div>
<article class="bd-article">
<h1>Source code for ast</h1><div class="highlight"><pre>
<span></span><span class="sd">"""</span>
<span class="sd">    ast</span>
<span class="sd">    ~~~</span>

<span class="sd">    The `ast` module helps Python applications to process trees of the Python</span>
<span class="sd">    abstract syntax grammar.  The abstract syntax itself might change with</span>
<span class="sd">    each Python release; this module helps to find out programmatically what</span>
<span class="sd">    the current grammar looks like and allows modifications of it.</span>

<span class="sd">    An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as</span>
<span class="sd">    a flag to the `compile()` builtin function or by using the `parse()`</span>
<span class="sd">    function from this module.  The result will be a tree of objects whose</span>
<span class="sd">    classes all inherit from `ast.AST`.</span>

<span class="sd">    A modified abstract syntax tree can be compiled into a Python code object</span>
<span class="sd">    using the built-in `compile()` function.</span>

<span class="sd">    Additionally various helper functions are provided that make working with</span>
<span class="sd">    the trees simpler.  The main intention of the helper functions and this</span>
<span class="sd">    module in general is to provide an easy to use interface for libraries</span>
<span class="sd">    that work tightly with the python syntax (template engines for example).</span>


<span class="sd">    :copyright: Copyright 2008 by Armin Ronacher.</span>
<span class="sd">    :license: Python License.</span>
<span class="sd">"""</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">_ast</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">contextmanager</span><span class="p">,</span> <span class="n">nullcontext</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">IntEnum</span><span class="p">,</span> <span class="n">auto</span><span class="p">,</span> <span class="n">_simple_enum</span>


<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s1">'&lt;unknown&gt;'</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'exec'</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span>
          <span class="n">type_comments</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">feature_version</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Parse the source into an AST node.</span>
<span class="sd">    Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).</span>
<span class="sd">    Pass type_comments=True to get back type comments where the syntax allows.</span>
<span class="sd">    """</span>
    <span class="n">flags</span> <span class="o">=</span> <span class="n">PyCF_ONLY_AST</span>
    <span class="k">if</span> <span class="n">type_comments</span><span class="p">:</span>
        <span class="n">flags</span> <span class="o">|=</span> <span class="n">PyCF_TYPE_COMMENTS</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">feature_version</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
        <span class="n">major</span><span class="p">,</span> <span class="n">minor</span> <span class="o">=</span> <span class="n">feature_version</span>  <span class="c1"># Should be a 2-tuple.</span>
        <span class="k">assert</span> <span class="n">major</span> <span class="o">==</span> <span class="mi">3</span>
        <span class="n">feature_version</span> <span class="o">=</span> <span class="n">minor</span>
    <span class="k">elif</span> <span class="n">feature_version</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">feature_version</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="c1"># Else it should be an int giving the minor version for 3.x.</span>
    <span class="k">return</span> <span class="nb">compile</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
                   <span class="n">_feature_version</span><span class="o">=</span><span class="n">feature_version</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">literal_eval</span><span class="p">(</span><span class="n">node_or_string</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Evaluate an expression node or a string containing only a Python</span>
<span class="sd">    expression.  The string or node provided may only consist of the following</span>
<span class="sd">    Python literal structures: strings, bytes, numbers, tuples, lists, dicts,</span>
<span class="sd">    sets, booleans, and None.</span>

<span class="sd">    Caution: A complex expression can overflow the C stack and cause a crash.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_or_string</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">node_or_string</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">node_or_string</span><span class="o">.</span><span class="n">lstrip</span><span class="p">(</span><span class="s2">" </span><span class="se">\t</span><span class="s2">"</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s1">'eval'</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node_or_string</span><span class="p">,</span> <span class="n">Expression</span><span class="p">):</span>
        <span class="n">node_or_string</span> <span class="o">=</span> <span class="n">node_or_string</span><span class="o">.</span><span class="n">body</span>
    <span class="k">def</span> <span class="nf">_raise_malformed_node</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">"malformed node or string"</span>
        <span class="k">if</span> <span class="n">lno</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">'lineno'</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s1">' on line </span><span class="si">{</span><span class="n">lno</span><span class="si">}</span><span class="s1">'</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">': </span><span class="si">{</span><span class="n">node</span><span class="si">!r}</span><span class="s1">'</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_convert_num</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
            <span class="n">_raise_malformed_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
    <span class="k">def</span> <span class="nf">_convert_signed_num</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">UnaryOp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="p">(</span><span class="n">UAdd</span><span class="p">,</span> <span class="n">USub</span><span class="p">)):</span>
            <span class="n">operand</span> <span class="o">=</span> <span class="n">_convert_num</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">UAdd</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">+</span> <span class="n">operand</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span> <span class="n">operand</span>
        <span class="k">return</span> <span class="n">_convert_num</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_convert</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">List</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_convert</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Set</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_convert</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">))</span>
        <span class="k">elif</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Call</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="p">,</span> <span class="n">Name</span><span class="p">)</span> <span class="ow">and</span>
              <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="s1">'set'</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">keywords</span> <span class="o">==</span> <span class="p">[]):</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">):</span>
                <span class="n">_raise_malformed_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_convert</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">),</span>
                            <span class="nb">map</span><span class="p">(</span><span class="n">_convert</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">)))</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">BinOp</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="p">(</span><span class="n">Add</span><span class="p">,</span> <span class="n">Sub</span><span class="p">)):</span>
            <span class="n">left</span> <span class="o">=</span> <span class="n">_convert_signed_num</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="n">right</span> <span class="o">=</span> <span class="n">_convert_num</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">))</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="nb">complex</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="p">,</span> <span class="n">Add</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">left</span> <span class="o">+</span> <span class="n">right</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">left</span> <span class="o">-</span> <span class="n">right</span>
        <span class="k">return</span> <span class="n">_convert_signed_num</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">_convert</span><span class="p">(</span><span class="n">node_or_string</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">dump</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">annotate_fields</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">include_attributes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Return a formatted dump of the tree in node.  This is mainly useful for</span>
<span class="sd">    debugging purposes.  If annotate_fields is true (by default),</span>
<span class="sd">    the returned string will show the names and the values for fields.</span>
<span class="sd">    If annotate_fields is false, the result string will be more compact by</span>
<span class="sd">    omitting unambiguous field names.  Attributes such as line</span>
<span class="sd">    numbers and column offsets are not dumped by default.  If this is wanted,</span>
<span class="sd">    include_attributes can be set to true.  If indent is a non-negative</span>
<span class="sd">    integer or string, then the tree will be pretty-printed with that indent</span>
<span class="sd">    level. None (the default) selects the single line representation.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_format</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">indent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">level</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span> <span class="o">+</span> <span class="n">indent</span> <span class="o">*</span> <span class="n">level</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="s1">',</span><span class="se">\n</span><span class="s1">'</span> <span class="o">+</span> <span class="n">indent</span> <span class="o">*</span> <span class="n">level</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prefix</span> <span class="o">=</span> <span class="s1">''</span>
            <span class="n">sep</span> <span class="o">=</span> <span class="s1">', '</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
            <span class="bp">cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">allsimple</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">keywords</span> <span class="o">=</span> <span class="n">annotate_fields</span>
            <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">keywords</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">keywords</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">continue</span>
                <span class="n">value</span><span class="p">,</span> <span class="n">simple</span> <span class="o">=</span> <span class="n">_format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
                <span class="n">allsimple</span> <span class="o">=</span> <span class="n">allsimple</span> <span class="ow">and</span> <span class="n">simple</span>
                <span class="k">if</span> <span class="n">keywords</span><span class="p">:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">include_attributes</span> <span class="ow">and</span> <span class="n">node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">value</span><span class="p">,</span> <span class="n">simple</span> <span class="o">=</span> <span class="n">_format</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">level</span><span class="p">)</span>
                    <span class="n">allsimple</span> <span class="o">=</span> <span class="n">allsimple</span> <span class="ow">and</span> <span class="n">simple</span>
                    <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">'</span><span class="si">%s</span><span class="s1">=</span><span class="si">%s</span><span class="s1">'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">allsimple</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">3</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">', '</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="ow">not</span> <span class="n">args</span>
            <span class="k">return</span> <span class="s1">'</span><span class="si">%s</span><span class="s1">(</span><span class="si">%s%s</span><span class="s1">)'</span> <span class="o">%</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">prefix</span><span class="p">,</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">'[]'</span><span class="p">,</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="s1">'[</span><span class="si">%s%s</span><span class="s1">]'</span> <span class="o">%</span> <span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="n">sep</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">level</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">node</span><span class="p">)),</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">repr</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">'expected AST, got </span><span class="si">%r</span><span class="s1">'</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">indent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indent</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">indent</span> <span class="o">=</span> <span class="s1">' '</span> <span class="o">*</span> <span class="n">indent</span>
    <span class="k">return</span> <span class="n">_format</span><span class="p">(</span><span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">copy_location</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">old_node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`</span>
<span class="sd">    attributes) from *old_node* to *new_node* if possible, and return *new_node*.</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="s1">'lineno'</span><span class="p">,</span> <span class="s1">'col_offset'</span><span class="p">,</span> <span class="s1">'end_lineno'</span><span class="p">,</span> <span class="s1">'end_col_offset'</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">old_node</span><span class="o">.</span><span class="n">_attributes</span> <span class="ow">and</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">new_node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">old_node</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="c1"># end_lineno and end_col_offset are optional attributes, and they</span>
            <span class="c1"># should be copied whether the value is None or not.</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span>
                <span class="nb">hasattr</span><span class="p">(</span><span class="n">old_node</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">attr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"end_"</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">new_node</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">new_node</span>


<span class="k">def</span> <span class="nf">fix_missing_locations</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    When you compile a node tree with compile(), the compiler expects lineno and</span>
<span class="sd">    col_offset attributes for every node that supports them.  This is rather</span>
<span class="sd">    tedious to fill in for generated nodes, so this helper adds these attributes</span>
<span class="sd">    recursively where not already set, by setting them to the values of the</span>
<span class="sd">    parent node.  It works recursively starting at *node*.</span>
<span class="sd">    """</span>
    <span class="k">def</span> <span class="nf">_fix</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">col_offset</span><span class="p">,</span> <span class="n">end_lineno</span><span class="p">,</span> <span class="n">end_col_offset</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">'lineno'</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">'lineno'</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="n">lineno</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lineno</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span>
        <span class="k">if</span> <span class="s1">'end_lineno'</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">'end_lineno'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">end_lineno</span> <span class="o">=</span> <span class="n">end_lineno</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end_lineno</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">end_lineno</span>
        <span class="k">if</span> <span class="s1">'col_offset'</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">'col_offset'</span><span class="p">):</span>
                <span class="n">node</span><span class="o">.</span><span class="n">col_offset</span> <span class="o">=</span> <span class="n">col_offset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">col_offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">col_offset</span>
        <span class="k">if</span> <span class="s1">'end_col_offset'</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s1">'end_col_offset'</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">node</span><span class="o">.</span><span class="n">end_col_offset</span> <span class="o">=</span> <span class="n">end_col_offset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end_col_offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">end_col_offset</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">iter_child_nodes</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="n">_fix</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">col_offset</span><span class="p">,</span> <span class="n">end_lineno</span><span class="p">,</span> <span class="n">end_col_offset</span><span class="p">)</span>
    <span class="n">_fix</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">node</span>


<span class="k">def</span> <span class="nf">increment_lineno</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Increment the line number and end line number of each node in the tree</span>
<span class="sd">    starting at *node* by *n*. This is useful to "move code" to a different</span>
<span class="sd">    location in a file.</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">walk</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="c1"># TypeIgnore is a special case where lineno is not an attribute</span>
        <span class="c1"># but rather a field of the node itself.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">TypeIgnore</span><span class="p">):</span>
            <span class="n">child</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">'lineno'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="s1">'lineno'</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_attributes</span><span class="p">:</span>
            <span class="n">child</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s1">'lineno'</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="s2">"end_lineno"</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="n">_attributes</span>
            <span class="ow">and</span> <span class="p">(</span><span class="n">end_lineno</span> <span class="o">:=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s2">"end_lineno"</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="n">child</span><span class="o">.</span><span class="n">end_lineno</span> <span class="o">=</span> <span class="n">end_lineno</span> <span class="o">+</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">node</span>


<span class="k">def</span> <span class="nf">iter_fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``</span>
<span class="sd">    that is present on *node*.</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">field</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>


<span class="k">def</span> <span class="nf">iter_child_nodes</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Yield all direct child nodes of *node*, that is, all fields that are nodes</span>
<span class="sd">    and all items of fields that are lists of nodes.</span>
<span class="sd">    """</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">iter_fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
            <span class="k">yield</span> <span class="n">field</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">field</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
                    <span class="k">yield</span> <span class="n">item</span>


<span class="k">def</span> <span class="nf">get_docstring</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Return the docstring for the given node or None if no docstring can</span>
<span class="sd">    be found.  If the node provided does not have docstrings a TypeError</span>
<span class="sd">    will be raised.</span>

<span class="sd">    If *clean* is `True`, all tabs are expanded to spaces and any whitespace</span>
<span class="sd">    that can be uniformly removed from the second line onwards is removed.</span>
<span class="sd">    """</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">AsyncFunctionDef</span><span class="p">,</span> <span class="n">FunctionDef</span><span class="p">,</span> <span class="n">ClassDef</span><span class="p">,</span> <span class="n">Module</span><span class="p">)):</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">"</span><span class="si">%r</span><span class="s2"> can't have docstrings"</span> <span class="o">%</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Expr</span><span class="p">)):</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">value</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Str</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">s</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">clean</span><span class="p">:</span>
        <span class="kn">import</span> <span class="nn">inspect</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">cleandoc</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">text</span>


<span class="k">def</span> <span class="nf">_splitlines_no_ff</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Split a string into lines ignoring form feed and other chars.</span>

<span class="sd">    This mimics how the Python parser splits source code.</span>
<span class="sd">    """</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">next_line</span> <span class="o">=</span> <span class="s1">''</span>
    <span class="k">while</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">source</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">next_line</span> <span class="o">+=</span> <span class="n">c</span>
        <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Keep \r\n together</span>
        <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s1">'</span><span class="se">\r</span><span class="s1">'</span> <span class="ow">and</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">source</span><span class="p">)</span> <span class="ow">and</span> <span class="n">source</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">==</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span><span class="p">:</span>
            <span class="n">next_line</span> <span class="o">+=</span> <span class="s1">'</span><span class="se">\n</span><span class="s1">'</span>
            <span class="n">idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="s1">'</span><span class="se">\r\n</span><span class="s1">'</span><span class="p">:</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_line</span><span class="p">)</span>
            <span class="n">next_line</span> <span class="o">=</span> <span class="s1">''</span>

    <span class="k">if</span> <span class="n">next_line</span><span class="p">:</span>
        <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">next_line</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">lines</span>


<span class="k">def</span> <span class="nf">_pad_whitespace</span><span class="p">(</span><span class="n">source</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">"""Replace all chars except '\f\t' in a line with spaces."""</span>
    <span class="n">result</span> <span class="o">=</span> <span class="s1">''</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">source</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="s1">'</span><span class="se">\f\t</span><span class="s1">'</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">c</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="s1">' '</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">def</span> <span class="nf">get_source_segment</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">padded</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Get source code segment of the *source* that generated *node*.</span>

<span class="sd">    If some location information (`lineno`, `end_lineno`, `col_offset`,</span>
<span class="sd">    or `end_col_offset`) is missing, return None.</span>

<span class="sd">    If *padded* is `True`, the first line of a multi-line statement will</span>
<span class="sd">    be padded with spaces to match its original position.</span>
<span class="sd">    """</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">end_lineno</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">end_col_offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">lineno</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">lineno</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">end_lineno</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">end_lineno</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">col_offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">col_offset</span>
        <span class="n">end_col_offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">end_col_offset</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="n">lines</span> <span class="o">=</span> <span class="n">_splitlines_no_ff</span><span class="p">(</span><span class="n">source</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">end_lineno</span> <span class="o">==</span> <span class="n">lineno</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">lines</span><span class="p">[</span><span class="n">lineno</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">()[</span><span class="n">col_offset</span><span class="p">:</span><span class="n">end_col_offset</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">padded</span><span class="p">:</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="n">_pad_whitespace</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="n">lineno</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">()[:</span><span class="n">col_offset</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">())</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">padding</span> <span class="o">=</span> <span class="s1">''</span>

    <span class="n">first</span> <span class="o">=</span> <span class="n">padding</span> <span class="o">+</span> <span class="n">lines</span><span class="p">[</span><span class="n">lineno</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">()[</span><span class="n">col_offset</span><span class="p">:]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">last</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">end_lineno</span><span class="p">]</span><span class="o">.</span><span class="n">encode</span><span class="p">()[:</span><span class="n">end_col_offset</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">lines</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="n">lineno</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">end_lineno</span><span class="p">]</span>

    <span class="n">lines</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">first</span><span class="p">)</span>
    <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">last</span><span class="p">)</span>
    <span class="k">return</span> <span class="s1">''</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">walk</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    Recursively yield all descendant nodes in the tree starting at *node*</span>
<span class="sd">    (including *node* itself), in no specified order.  This is useful if you</span>
<span class="sd">    only want to modify nodes in place and don't care about the context.</span>
<span class="sd">    """</span>
    <span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>
    <span class="n">todo</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="n">node</span><span class="p">])</span>
    <span class="k">while</span> <span class="n">todo</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">todo</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
        <span class="n">todo</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">iter_child_nodes</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="k">yield</span> <span class="n">node</span>


<span class="k">class</span> <span class="nc">NodeVisitor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    A node visitor base class that walks the abstract syntax tree and calls a</span>
<span class="sd">    visitor function for every node found.  This function may return a value</span>
<span class="sd">    which is forwarded by the `visit` method.</span>

<span class="sd">    This class is meant to be subclassed, with the subclass adding visitor</span>
<span class="sd">    methods.</span>

<span class="sd">    Per default the visitor functions for the nodes are ``'visit_'`` +</span>
<span class="sd">    class name of the node.  So a `TryFinally` node visit function would</span>
<span class="sd">    be `visit_TryFinally`.  This behavior can be changed by overriding</span>
<span class="sd">    the `visit` method.  If no visitor function exists for a node</span>
<span class="sd">    (return value `None`) the `generic_visit` visitor is used instead.</span>

<span class="sd">    Don't use the `NodeVisitor` if you want to apply changes to nodes during</span>
<span class="sd">    traversing.  For this a special visitor exists (`NodeTransformer`) that</span>
<span class="sd">    allows modifications.</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Visit a node."""</span>
        <span class="n">method</span> <span class="o">=</span> <span class="s1">'visit_'</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="n">visitor</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">visitor</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Called if no explicit visitor function exists for a node."""</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">iter_fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
        <span class="n">type_name</span> <span class="o">=</span> <span class="n">_const_node_type_names</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">type_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">_const_node_type_names</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
                    <span class="n">type_name</span> <span class="o">=</span> <span class="n">name</span>
                    <span class="k">break</span>
        <span class="k">if</span> <span class="n">type_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">'visit_'</span> <span class="o">+</span> <span class="n">type_name</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">visitor</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">import</span> <span class="nn">warnings</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> is deprecated; add visit_Constant"</span><span class="p">,</span>
                              <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">visitor</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">generic_visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">NodeTransformer</span><span class="p">(</span><span class="n">NodeVisitor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""</span>
<span class="sd">    A :class:`NodeVisitor` subclass that walks the abstract syntax tree and</span>
<span class="sd">    allows modification of nodes.</span>

<span class="sd">    The `NodeTransformer` will walk the AST and use the return value of the</span>
<span class="sd">    visitor methods to replace or remove the old node.  If the return value of</span>
<span class="sd">    the visitor method is ``None``, the node will be removed from its location,</span>
<span class="sd">    otherwise it is replaced with the return value.  The return value may be the</span>
<span class="sd">    original node in which case no replacement takes place.</span>

<span class="sd">    Here is an example transformer that rewrites all occurrences of name lookups</span>
<span class="sd">    (``foo``) to ``data['foo']``::</span>

<span class="sd">       class RewriteName(NodeTransformer):</span>

<span class="sd">           def visit_Name(self, node):</span>
<span class="sd">               return Subscript(</span>
<span class="sd">                   value=Name(id='data', ctx=Load()),</span>
<span class="sd">                   slice=Constant(value=node.id),</span>
<span class="sd">                   ctx=node.ctx</span>
<span class="sd">               )</span>

<span class="sd">    Keep in mind that if the node you're operating on has child nodes you must</span>
<span class="sd">    either transform the child nodes yourself or call the :meth:`generic_visit`</span>
<span class="sd">    method for the node first.</span>

<span class="sd">    For nodes that were part of a collection of statements (that applies to all</span>
<span class="sd">    statement nodes), the visitor may also return a list of nodes rather than</span>
<span class="sd">    just a single node.</span>

<span class="sd">    Usually you use the transformer like this::</span>

<span class="sd">       node = YourTransformer().visit(node)</span>
<span class="sd">    """</span>

    <span class="k">def</span> <span class="nf">generic_visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="n">old_value</span> <span class="ow">in</span> <span class="n">iter_fields</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">new_values</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">old_value</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
                            <span class="n">new_values</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                            <span class="k">continue</span>
                    <span class="n">new_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">old_value</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">new_values</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">old_value</span><span class="p">,</span> <span class="n">AST</span><span class="p">):</span>
                <span class="n">new_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">old_value</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">new_node</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="nb">delattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">new_node</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">node</span>


<span class="c1"># If the ast module is loaded more than once, only add deprecated methods once</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Constant</span><span class="p">,</span> <span class="s1">'n'</span><span class="p">):</span>
    <span class="c1"># The following code is for backward compatibility.</span>
    <span class="c1"># It will be removed in future.</span>

    <span class="k">def</span> <span class="nf">_getter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Deprecated. Use value instead."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span> <span class="nf">_setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">Constant</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getter</span><span class="p">,</span> <span class="n">_setter</span><span class="p">)</span>
    <span class="n">Constant</span><span class="o">.</span><span class="n">s</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_getter</span><span class="p">,</span> <span class="n">_setter</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_ABC</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">cls</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">=</span> <span class="s2">"""Deprecated AST node class. Use ast.Constant instead"""</span>

    <span class="k">def</span> <span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inst</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">Constant</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">_const_types</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">value</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_const_types</span><span class="p">[</span><span class="bp">cls</span><span class="p">])</span> <span class="ow">and</span>
                    <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">_const_types_not</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="p">()))</span>
                <span class="p">)</span>
        <span class="k">return</span> <span class="nb">type</span><span class="o">.</span><span class="fm">__instancecheck__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">inst</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">_new</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_fields</span><span class="p">:</span>
            <span class="c1"># arbitrary keyword arguments are accepted</span>
            <span class="k">continue</span>
        <span class="n">pos</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">_fields</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> got multiple values for argument </span><span class="si">{</span><span class="n">key</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">in</span> <span class="n">_const_types</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Constant</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Constant</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Num</span><span class="p">(</span><span class="n">Constant</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ABC</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'n'</span><span class="p">,)</span>
    <span class="fm">__new__</span> <span class="o">=</span> <span class="n">_new</span>

<span class="k">class</span> <span class="nc">Str</span><span class="p">(</span><span class="n">Constant</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ABC</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'s'</span><span class="p">,)</span>
    <span class="fm">__new__</span> <span class="o">=</span> <span class="n">_new</span>

<span class="k">class</span> <span class="nc">Bytes</span><span class="p">(</span><span class="n">Constant</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ABC</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'s'</span><span class="p">,)</span>
    <span class="fm">__new__</span> <span class="o">=</span> <span class="n">_new</span>

<span class="k">class</span> <span class="nc">NameConstant</span><span class="p">(</span><span class="n">Constant</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ABC</span><span class="p">):</span>
    <span class="fm">__new__</span> <span class="o">=</span> <span class="n">_new</span>

<span class="k">class</span> <span class="nc">Ellipsis</span><span class="p">(</span><span class="n">Constant</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">_ABC</span><span class="p">):</span>
    <span class="n">_fields</span> <span class="o">=</span> <span class="p">()</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">Constant</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Constant</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">_const_types</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Num</span><span class="p">:</span> <span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">),</span>
    <span class="n">Str</span><span class="p">:</span> <span class="p">(</span><span class="nb">str</span><span class="p">,),</span>
    <span class="n">Bytes</span><span class="p">:</span> <span class="p">(</span><span class="nb">bytes</span><span class="p">,),</span>
    <span class="n">NameConstant</span><span class="p">:</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span> <span class="nb">bool</span><span class="p">),</span>
    <span class="bp">Ellipsis</span><span class="p">:</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="o">...</span><span class="p">),),</span>
<span class="p">}</span>
<span class="n">_const_types_not</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Num</span><span class="p">:</span> <span class="p">(</span><span class="nb">bool</span><span class="p">,),</span>
<span class="p">}</span>

<span class="n">_const_node_type_names</span> <span class="o">=</span> <span class="p">{</span>
    <span class="nb">bool</span><span class="p">:</span> <span class="s1">'NameConstant'</span><span class="p">,</span>  <span class="c1"># should be before int</span>
    <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">):</span> <span class="s1">'NameConstant'</span><span class="p">,</span>
    <span class="nb">int</span><span class="p">:</span> <span class="s1">'Num'</span><span class="p">,</span>
    <span class="nb">float</span><span class="p">:</span> <span class="s1">'Num'</span><span class="p">,</span>
    <span class="nb">complex</span><span class="p">:</span> <span class="s1">'Num'</span><span class="p">,</span>
    <span class="nb">str</span><span class="p">:</span> <span class="s1">'Str'</span><span class="p">,</span>
    <span class="nb">bytes</span><span class="p">:</span> <span class="s1">'Bytes'</span><span class="p">,</span>
    <span class="nb">type</span><span class="p">(</span><span class="o">...</span><span class="p">):</span> <span class="s1">'Ellipsis'</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">slice</span><span class="p">(</span><span class="n">AST</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Deprecated AST node class."""</span>

<span class="k">class</span> <span class="nc">Index</span><span class="p">(</span><span class="nb">slice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Deprecated AST node class. Use the index value directly instead."""</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span>

<span class="k">class</span> <span class="nc">ExtSlice</span><span class="p">(</span><span class="nb">slice</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Deprecated AST node class. Use ast.Tuple instead."""</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Tuple</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">dims</span><span class="p">),</span> <span class="n">Load</span><span class="p">(),</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="c1"># If the ast module is loaded more than once, only add deprecated methods once</span>
<span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">Tuple</span><span class="p">,</span> <span class="s1">'dims'</span><span class="p">):</span>
    <span class="c1"># The following code is for backward compatibility.</span>
    <span class="c1"># It will be removed in future.</span>

    <span class="k">def</span> <span class="nf">_dims_getter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Deprecated. Use elts instead."""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elts</span>

    <span class="k">def</span> <span class="nf">_dims_setter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elts</span> <span class="o">=</span> <span class="n">value</span>

    <span class="n">Tuple</span><span class="o">.</span><span class="n">dims</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_dims_getter</span><span class="p">,</span> <span class="n">_dims_setter</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Suite</span><span class="p">(</span><span class="n">mod</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Deprecated AST node class.  Unused in Python 3."""</span>

<span class="k">class</span> <span class="nc">AugLoad</span><span class="p">(</span><span class="n">expr_context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Deprecated AST node class.  Unused in Python 3."""</span>

<span class="k">class</span> <span class="nc">AugStore</span><span class="p">(</span><span class="n">expr_context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Deprecated AST node class.  Unused in Python 3."""</span>

<span class="k">class</span> <span class="nc">Param</span><span class="p">(</span><span class="n">expr_context</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Deprecated AST node class.  Unused in Python 3."""</span>


<span class="c1"># Large float and imaginary literals get turned into infinities in the AST.</span>
<span class="c1"># We unparse those infinities to INFSTR.</span>
<span class="n">_INFSTR</span> <span class="o">=</span> <span class="s2">"1e"</span> <span class="o">+</span> <span class="nb">repr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">float_info</span><span class="o">.</span><span class="n">max_10_exp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

<span class="nd">@_simple_enum</span><span class="p">(</span><span class="n">IntEnum</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_Precedence</span><span class="p">:</span>
<span class="w">    </span><span class="sd">"""Precedence table that originated from python grammar."""</span>

    <span class="n">NAMED_EXPR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>      <span class="c1"># &lt;target&gt; := &lt;expr1&gt;</span>
    <span class="n">TUPLE</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>           <span class="c1"># &lt;expr1&gt;, &lt;expr2&gt;</span>
    <span class="n">YIELD</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>           <span class="c1"># 'yield', 'yield from'</span>
    <span class="n">TEST</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>            <span class="c1"># 'if'-'else', 'lambda'</span>
    <span class="n">OR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>              <span class="c1"># 'or'</span>
    <span class="n">AND</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>             <span class="c1"># 'and'</span>
    <span class="n">NOT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>             <span class="c1"># 'not'</span>
    <span class="n">CMP</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>             <span class="c1"># '&lt;', '&gt;', '==', '&gt;=', '&lt;=', '!=',</span>
                             <span class="c1"># 'in', 'not in', 'is', 'is not'</span>
    <span class="n">EXPR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>
    <span class="n">BOR</span> <span class="o">=</span> <span class="n">EXPR</span>               <span class="c1"># '|'</span>
    <span class="n">BXOR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>            <span class="c1"># '^'</span>
    <span class="n">BAND</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>            <span class="c1"># '&amp;'</span>
    <span class="n">SHIFT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>           <span class="c1"># '&lt;&lt;', '&gt;&gt;'</span>
    <span class="n">ARITH</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>           <span class="c1"># '+', '-'</span>
    <span class="n">TERM</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>            <span class="c1"># '*', '@', '/', '%', '//'</span>
    <span class="n">FACTOR</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>          <span class="c1"># unary '+', '-', '~'</span>
    <span class="n">POWER</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>           <span class="c1"># '**'</span>
    <span class="n">AWAIT</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>           <span class="c1"># 'await'</span>
    <span class="n">ATOM</span> <span class="o">=</span> <span class="n">auto</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>


<span class="n">_SINGLE_QUOTES</span> <span class="o">=</span> <span class="p">(</span><span class="s2">"'"</span><span class="p">,</span> <span class="s1">'"'</span><span class="p">)</span>
<span class="n">_MULTI_QUOTES</span> <span class="o">=</span> <span class="p">(</span><span class="s1">'"""'</span><span class="p">,</span> <span class="s2">"'''"</span><span class="p">)</span>
<span class="n">_ALL_QUOTES</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">_SINGLE_QUOTES</span><span class="p">,</span> <span class="o">*</span><span class="n">_MULTI_QUOTES</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">_Unparser</span><span class="p">(</span><span class="n">NodeVisitor</span><span class="p">):</span>
<span class="w">    </span><span class="sd">"""Methods in this class recursively traverse an AST and</span>
<span class="sd">    output source code for the abstract syntax; original formatting</span>
<span class="sd">    is disregarded."""</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">_avoid_backslashes</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_precedences</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type_ignores</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indent</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_avoid_backslashes</span> <span class="o">=</span> <span class="n">_avoid_backslashes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_in_try_star</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">interleave</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inter</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Call f on each item in seq, calling inter() in between."""</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span><span class="p">(</span><span class="nb">next</span><span class="p">(</span><span class="n">seq</span><span class="p">))</span>
        <span class="k">except</span> <span class="ne">StopIteration</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">seq</span><span class="p">:</span>
                <span class="n">inter</span><span class="p">()</span>
                <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">items_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">traverser</span><span class="p">,</span> <span class="n">items</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Traverse and separate the given *items* with a comma and append it to</span>
<span class="sd">        the buffer. If *items* is a single item sequence, a trailing comma</span>
<span class="sd">        will be added."""</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">traverser</span><span class="p">(</span><span class="n">items</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">","</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="n">traverser</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">maybe_newline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Adds a newline if it isn't the start of generated source"""</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">""</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Indent a piece of text and append it, according to the current</span>
<span class="sd">        indentation level"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maybe_newline</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"    "</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_indent</span> <span class="o">+</span> <span class="n">text</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">text</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Add new source parts"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">buffered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">buffer</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">original_source</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">buffer</span>
        <span class="k">yield</span> <span class="n">buffer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="n">original_source</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">extra</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""A context manager for preparing the source for blocks. It adds</span>
<span class="sd">        the character':', increases the indentation on enter and decreases</span>
<span class="sd">        the indentation on exit. If *extra* is given, it will be directly</span>
<span class="sd">        appended after the colon character.</span>
<span class="sd">        """</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">":"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">extra</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">extra</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indent</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">yield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_indent</span> <span class="o">-=</span> <span class="mi">1</span>

    <span class="nd">@contextmanager</span>
    <span class="k">def</span> <span class="nf">delimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""A context manager for preparing the source for expressions. It adds</span>
<span class="sd">        *start* to the buffer and enters, after exit it adds *end*."""</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
        <span class="k">yield</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">delimit_if</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">nullcontext</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">require_parens</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precedence</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Shortcut to adding precedence related parens"""</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit_if</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_precedence</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">precedence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_precedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_precedences</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_precedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">precedence</span><span class="p">,</span> <span class="o">*</span><span class="n">nodes</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_precedences</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">precedence</span>

    <span class="k">def</span> <span class="nf">get_raw_docstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""If a docstring node is found in the body of the *node* parameter,</span>
<span class="sd">        return that docstring node, None otherwise.</span>

<span class="sd">        Logic mirrored from ``_PyAST_GetDocString``."""</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span>
            <span class="n">node</span><span class="p">,</span> <span class="p">(</span><span class="n">AsyncFunctionDef</span><span class="p">,</span> <span class="n">FunctionDef</span><span class="p">,</span> <span class="n">ClassDef</span><span class="p">,</span> <span class="n">Module</span><span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Expr</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">node</span>

    <span class="k">def</span> <span class="nf">get_type_comment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">comment</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_type_ignores</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">lineno</span><span class="p">)</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">type_comment</span>
        <span class="k">if</span> <span class="n">comment</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">" # type: </span><span class="si">{</span><span class="n">comment</span><span class="si">}</span><span class="s2">"</span>

    <span class="k">def</span> <span class="nf">traverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">node</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="c1"># Note: as visit() resets the output text, do NOT rely on</span>
    <span class="c1"># NodeVisitor.generic_visit to handle any nodes (as it calls back in to</span>
    <span class="c1"># the subclass visit() method, which resets self._source to an empty list)</span>
    <span class="k">def</span> <span class="nf">visit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Outputs a source code string that, if converted back to an ast</span>
<span class="sd">        (using ast.parse) will generate an AST equivalent to *node*"""</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_source</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_source</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_docstring_and_traverse_body</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">docstring</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_raw_docstring</span><span class="p">(</span><span class="n">node</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_docstring</span><span class="p">(</span><span class="n">docstring</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Module</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type_ignores</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">ignore</span><span class="o">.</span><span class="n">lineno</span><span class="p">:</span> <span class="sa">f</span><span class="s2">"ignore</span><span class="si">{</span><span class="n">ignore</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">"</span>
            <span class="k">for</span> <span class="n">ignore</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">type_ignores</span>
        <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_docstring_and_traverse_body</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_type_ignores</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">visit_FunctionType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span>
                <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">argtypes</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" -&gt; "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">returns</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Expr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">YIELD</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_NamedExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">NAMED_EXPR</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" := "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Import</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"import "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_ImportFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"from "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"."</span> <span class="o">*</span> <span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">level</span> <span class="ow">or</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">module</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">module</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" import "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Assign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TUPLE</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" = "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">type_comment</span> <span class="o">:=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_type_comment</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">type_comment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_AugAssign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">+</span> <span class="s2">"= "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_AnnAssign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">()</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit_if</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">,</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">simple</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">,</span> <span class="n">Name</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">": "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" = "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Return</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"return"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Pass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"pass"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Break</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"break"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Continue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"continue"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Delete</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"del "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">targets</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Assert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"assert "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">msg</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Global</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"global "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Nonlocal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"nonlocal "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Await</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">AWAIT</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"await"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Yield</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">YIELD</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"yield"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_YieldFrom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">YIELD</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"yield from "</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">"Node can't be used without a value attribute."</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Raise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"raise"</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">node</span><span class="o">.</span><span class="n">exc</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">cause</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Node can't use cause without an exception."</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">exc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">cause</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" from "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">cause</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">do_visit_try</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"try"</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ex</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">handlers</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">ex</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"else"</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">finalbody</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"finally"</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">finalbody</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Try</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">prev_in_try_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_try_star</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_try_star</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_visit_try</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_try_star</span> <span class="o">=</span> <span class="n">prev_in_try_star</span>

    <span class="k">def</span> <span class="nf">visit_TryStar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">prev_in_try_star</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_try_star</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_try_star</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_visit_try</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_in_try_star</span> <span class="o">=</span> <span class="n">prev_in_try_star</span>

    <span class="k">def</span> <span class="nf">visit_ExceptHandler</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"except*"</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_in_try_star</span> <span class="k">else</span> <span class="s2">"except"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" as "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_ClassDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maybe_newline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">deco</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">decorator_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"@"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">deco</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"class "</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit_if</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">,</span> <span class="n">condition</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">bases</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">keywords</span><span class="p">):</span>
            <span class="n">comma</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">bases</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">comma</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comma</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">comma</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comma</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_docstring_and_traverse_body</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_FunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function_helper</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">"def"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_AsyncFunctionDef</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_function_helper</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="s2">"async def"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_function_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">fill_suffix</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">maybe_newline</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">deco</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">decorator_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"@"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">deco</span><span class="p">)</span>
        <span class="n">def_str</span> <span class="o">=</span> <span class="n">fill_suffix</span> <span class="o">+</span> <span class="s2">" "</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">def_str</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">returns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" -&gt; "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">returns</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">extra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type_comment</span><span class="p">(</span><span class="n">node</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_docstring_and_traverse_body</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_For</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_for_helper</span><span class="p">(</span><span class="s2">"for "</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_AsyncFor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_for_helper</span><span class="p">(</span><span class="s2">"async for "</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_for_helper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fill</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">fill</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TUPLE</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" in "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">extra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type_comment</span><span class="p">(</span><span class="n">node</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"else"</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_If</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"if "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="c1"># collapse nested ifs into equivalent elifs.</span>
        <span class="k">while</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">If</span><span class="p">):</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"elif "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="c1"># final else</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"else"</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_While</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"while "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"else"</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_With</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"with "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">extra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type_comment</span><span class="p">(</span><span class="n">node</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_AsyncWith</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"async with "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">items</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">extra</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_type_comment</span><span class="p">(</span><span class="n">node</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_str_literal_helper</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">quote_types</span><span class="o">=</span><span class="n">_ALL_QUOTES</span><span class="p">,</span> <span class="n">escape_special_whitespace</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">"""Helper for writing string literals, minimizing escapes.</span>
<span class="sd">        Returns the tuple (string literal to write, possible quote types).</span>
<span class="sd">        """</span>
        <span class="k">def</span> <span class="nf">escape_char</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
            <span class="c1"># \n and \t are non-printable, but we only escape them if</span>
            <span class="c1"># escape_special_whitespace is True</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">escape_special_whitespace</span> <span class="ow">and</span> <span class="n">c</span> <span class="ow">in</span> <span class="s2">"</span><span class="se">\n\t</span><span class="s2">"</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">c</span>
            <span class="c1"># Always escape backslashes and other non-printable characters</span>
            <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="s2">"</span><span class="se">\\</span><span class="s2">"</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">c</span><span class="o">.</span><span class="n">isprintable</span><span class="p">():</span>
                <span class="k">return</span> <span class="n">c</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s2">"unicode_escape"</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">"ascii"</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">c</span>

        <span class="n">escaped_string</span> <span class="o">=</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">escape_char</span><span class="p">,</span> <span class="n">string</span><span class="p">))</span>
        <span class="n">possible_quotes</span> <span class="o">=</span> <span class="n">quote_types</span>
        <span class="k">if</span> <span class="s2">"</span><span class="se">\n</span><span class="s2">"</span> <span class="ow">in</span> <span class="n">escaped_string</span><span class="p">:</span>
            <span class="n">possible_quotes</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">possible_quotes</span> <span class="k">if</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">_MULTI_QUOTES</span><span class="p">]</span>
        <span class="n">possible_quotes</span> <span class="o">=</span> <span class="p">[</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">possible_quotes</span> <span class="k">if</span> <span class="n">q</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">escaped_string</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">possible_quotes</span><span class="p">:</span>
            <span class="c1"># If there aren't any possible_quotes, fallback to using repr</span>
            <span class="c1"># on the original string. Try to use a quote from quote_types,</span>
            <span class="c1"># e.g., so that we use triple quotes for docstrings.</span>
            <span class="n">string</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
            <span class="n">quote</span> <span class="o">=</span> <span class="nb">next</span><span class="p">((</span><span class="n">q</span> <span class="k">for</span> <span class="n">q</span> <span class="ow">in</span> <span class="n">quote_types</span> <span class="k">if</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">q</span><span class="p">),</span> <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">string</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">quote</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">escaped_string</span><span class="p">:</span>
            <span class="c1"># Sort so that we prefer '''"''' over """\""""</span>
            <span class="n">possible_quotes</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">q</span><span class="p">:</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">escaped_string</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># If we're using triple quotes and we'd need to escape a final</span>
            <span class="c1"># quote, escape it</span>
            <span class="k">if</span> <span class="n">possible_quotes</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">escaped_string</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">possible_quotes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">3</span>
                <span class="n">escaped_string</span> <span class="o">=</span> <span class="n">escaped_string</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s2">"</span><span class="se">\\</span><span class="s2">"</span> <span class="o">+</span> <span class="n">escaped_string</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">escaped_string</span><span class="p">,</span> <span class="n">possible_quotes</span>

    <span class="k">def</span> <span class="nf">_write_str_avoiding_backslashes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">quote_types</span><span class="o">=</span><span class="n">_ALL_QUOTES</span><span class="p">):</span>
<span class="w">        </span><span class="sd">"""Write string literal value with a best effort attempt to avoid backslashes."""</span>
        <span class="n">string</span><span class="p">,</span> <span class="n">quote_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_literal_helper</span><span class="p">(</span><span class="n">string</span><span class="p">,</span> <span class="n">quote_types</span><span class="o">=</span><span class="n">quote_types</span><span class="p">)</span>
        <span class="n">quote_type</span> <span class="o">=</span> <span class="n">quote_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">quote_type</span><span class="si">}{</span><span class="n">string</span><span class="si">}{</span><span class="n">quote_type</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_JoinedStr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"f"</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_avoid_backslashes</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffered</span><span class="p">()</span> <span class="k">as</span> <span class="n">buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_fstring_inner</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_str_avoiding_backslashes</span><span class="p">(</span><span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span>

        <span class="c1"># If we don't need to avoid backslashes globally (i.e., we only need</span>
        <span class="c1"># to avoid them inside FormattedValues), it's cosmetically preferred</span>
        <span class="c1"># to use escaped whitespace. That is, it's preferred to use backslashes</span>
        <span class="c1"># for cases like: f"{x}\n". To accomplish this, we keep track of what</span>
        <span class="c1"># in our buffer corresponds to FormattedValues and what corresponds to</span>
        <span class="c1"># Constant parts of the f-string, and allow escapes accordingly.</span>
        <span class="n">fstring_parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffered</span><span class="p">()</span> <span class="k">as</span> <span class="n">buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_fstring_inner</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">fstring_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="p">(</span><span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Constant</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="n">new_fstring_parts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">quote_types</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">_ALL_QUOTES</span><span class="p">)</span>
        <span class="n">fallback_to_repr</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">is_constant</span> <span class="ow">in</span> <span class="n">fstring_parts</span><span class="p">:</span>
            <span class="n">value</span><span class="p">,</span> <span class="n">new_quote_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_str_literal_helper</span><span class="p">(</span>
                <span class="n">value</span><span class="p">,</span>
                <span class="n">quote_types</span><span class="o">=</span><span class="n">quote_types</span><span class="p">,</span>
                <span class="n">escape_special_whitespace</span><span class="o">=</span><span class="n">is_constant</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">new_fstring_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">set</span><span class="p">(</span><span class="n">new_quote_types</span><span class="p">)</span><span class="o">.</span><span class="n">isdisjoint</span><span class="p">(</span><span class="n">quote_types</span><span class="p">):</span>
                <span class="n">fallback_to_repr</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
            <span class="n">quote_types</span> <span class="o">=</span> <span class="n">new_quote_types</span>

        <span class="k">if</span> <span class="n">fallback_to_repr</span><span class="p">:</span>
            <span class="c1"># If we weren't able to find a quote type that works for all parts</span>
            <span class="c1"># of the JoinedStr, fallback to using repr and triple single quotes.</span>
            <span class="n">quote_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"'''"</span><span class="p">]</span>
            <span class="n">new_fstring_parts</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">is_constant</span> <span class="ow">in</span> <span class="n">fstring_parts</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="nb">repr</span><span class="p">(</span><span class="s1">'"'</span> <span class="o">+</span> <span class="n">value</span><span class="p">)</span>  <span class="c1"># force repr to use single quotes</span>
                <span class="n">expected_prefix</span> <span class="o">=</span> <span class="s2">"'</span><span class="se">\"</span><span class="s2">"</span>
                <span class="k">assert</span> <span class="n">value</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">expected_prefix</span><span class="p">),</span> <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">new_fstring_parts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">expected_prefix</span><span class="p">):</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">value</span> <span class="o">=</span> <span class="s2">""</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">new_fstring_parts</span><span class="p">)</span>
        <span class="n">quote_type</span> <span class="o">=</span> <span class="n">quote_types</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">quote_type</span><span class="si">}{</span><span class="n">value</span><span class="si">}{</span><span class="n">quote_type</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_fstring_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">JoinedStr</span><span class="p">):</span>
            <span class="c1"># for both the f-string itself, and format_spec</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_fstring_inner</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"{"</span><span class="p">,</span> <span class="s2">"{{"</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"}"</span><span class="p">,</span> <span class="s2">"}}"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">FormattedValue</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visit_FormattedValue</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">"Unexpected node inside JoinedStr, </span><span class="si">{</span><span class="n">node</span><span class="si">!r}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_FormattedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">unparse_inner</span><span class="p">(</span><span class="n">inner</span><span class="p">):</span>
            <span class="n">unparser</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="n">_avoid_backslashes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">unparser</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">inner</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">unparser</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">inner</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"{"</span><span class="p">,</span> <span class="s2">"}"</span><span class="p">):</span>
            <span class="n">expr</span> <span class="o">=</span> <span class="n">unparse_inner</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">"</span><span class="se">\\</span><span class="s2">"</span> <span class="ow">in</span> <span class="n">expr</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">"Unable to avoid backslash in f-string expression part"</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">expr</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">"{"</span><span class="p">):</span>
                <span class="c1"># Separate pair of opening brackets as "{ {"</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">conversion</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">"!</span><span class="si">{</span><span class="nb">chr</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">conversion</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">format_spec</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">":"</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_write_fstring_inner</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">format_spec</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_docstring</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">"u"</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"u"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_str_avoiding_backslashes</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">quote_types</span><span class="o">=</span><span class="n">_MULTI_QUOTES</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_write_constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="nb">complex</span><span class="p">)):</span>
            <span class="c1"># Substitute overflowing decimal literal for AST infinities,</span>
            <span class="c1"># and inf - inf for NaNs.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                <span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"inf"</span><span class="p">,</span> <span class="n">_INFSTR</span><span class="p">)</span>
                <span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">"nan"</span><span class="p">,</span> <span class="sa">f</span><span class="s2">"(</span><span class="si">{</span><span class="n">_INFSTR</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">_INFSTR</span><span class="si">}</span><span class="s2">)"</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_avoid_backslashes</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_str_avoiding_backslashes</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">visit_Constant</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">items_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_write_constant</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">value</span> <span class="ow">is</span> <span class="o">...</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"..."</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="s2">"u"</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"u"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_List</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"["</span><span class="p">,</span> <span class="s2">"]"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_ListComp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"["</span><span class="p">,</span> <span class="s2">"]"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elt</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_GeneratorExp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elt</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_SetComp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"{"</span><span class="p">,</span> <span class="s2">"}"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elt</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_DictComp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"{"</span><span class="p">,</span> <span class="s2">"}"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">": "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">gen</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">generators</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">gen</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_comprehension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">is_async</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" async for "</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" for "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TUPLE</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">target</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" in "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">ifs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">iter</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">if_clause</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">ifs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" if "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">if_clause</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_IfExp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" if "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">test</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" else "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">orelse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"{"</span><span class="p">,</span> <span class="s2">"}"</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># `{}` would be interpreted as a dictionary literal, and</span>
            <span class="c1"># `set` might be shadowed. Thus:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">'{*()}'</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">write_key_value_pair</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">": "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">write_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># for dictionary unpacking operator in dicts {**{'y': 2}}</span>
                <span class="c1"># see PEP 448 for details</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"**"</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">EXPR</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">write_key_value_pair</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"{"</span><span class="p">,</span> <span class="s2">"}"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span>
                <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="n">write_item</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">keys</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Tuple</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit_if</span><span class="p">(</span>
            <span class="s2">"("</span><span class="p">,</span>
            <span class="s2">")"</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_precedence</span><span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">TUPLE</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">items_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">elts</span><span class="p">)</span>

    <span class="n">unop</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"Invert"</span><span class="p">:</span> <span class="s2">"~"</span><span class="p">,</span> <span class="s2">"Not"</span><span class="p">:</span> <span class="s2">"not"</span><span class="p">,</span> <span class="s2">"UAdd"</span><span class="p">:</span> <span class="s2">"+"</span><span class="p">,</span> <span class="s2">"USub"</span><span class="p">:</span> <span class="s2">"-"</span><span class="p">}</span>
    <span class="n">unop_precedence</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"not"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">NOT</span><span class="p">,</span>
        <span class="s2">"~"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">FACTOR</span><span class="p">,</span>
        <span class="s2">"+"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">FACTOR</span><span class="p">,</span>
        <span class="s2">"-"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">FACTOR</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">visit_UnaryOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unop</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
        <span class="n">operator_precedence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">unop_precedence</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">operator_precedence</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">operator</span><span class="p">)</span>
            <span class="c1"># factor prefixes (+, -, ~) shouldn't be separated</span>
            <span class="c1"># from the value they belong, (e.g: +1 instead of + 1)</span>
            <span class="k">if</span> <span class="n">operator_precedence</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">FACTOR</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">operator_precedence</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">operand</span><span class="p">)</span>

    <span class="n">binop</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"Add"</span><span class="p">:</span> <span class="s2">"+"</span><span class="p">,</span>
        <span class="s2">"Sub"</span><span class="p">:</span> <span class="s2">"-"</span><span class="p">,</span>
        <span class="s2">"Mult"</span><span class="p">:</span> <span class="s2">"*"</span><span class="p">,</span>
        <span class="s2">"MatMult"</span><span class="p">:</span> <span class="s2">"@"</span><span class="p">,</span>
        <span class="s2">"Div"</span><span class="p">:</span> <span class="s2">"/"</span><span class="p">,</span>
        <span class="s2">"Mod"</span><span class="p">:</span> <span class="s2">"%"</span><span class="p">,</span>
        <span class="s2">"LShift"</span><span class="p">:</span> <span class="s2">"&lt;&lt;"</span><span class="p">,</span>
        <span class="s2">"RShift"</span><span class="p">:</span> <span class="s2">"&gt;&gt;"</span><span class="p">,</span>
        <span class="s2">"BitOr"</span><span class="p">:</span> <span class="s2">"|"</span><span class="p">,</span>
        <span class="s2">"BitXor"</span><span class="p">:</span> <span class="s2">"^"</span><span class="p">,</span>
        <span class="s2">"BitAnd"</span><span class="p">:</span> <span class="s2">"&amp;"</span><span class="p">,</span>
        <span class="s2">"FloorDiv"</span><span class="p">:</span> <span class="s2">"//"</span><span class="p">,</span>
        <span class="s2">"Pow"</span><span class="p">:</span> <span class="s2">"**"</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">binop_precedence</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"+"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">ARITH</span><span class="p">,</span>
        <span class="s2">"-"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">ARITH</span><span class="p">,</span>
        <span class="s2">"*"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">TERM</span><span class="p">,</span>
        <span class="s2">"@"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">TERM</span><span class="p">,</span>
        <span class="s2">"/"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">TERM</span><span class="p">,</span>
        <span class="s2">"%"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">TERM</span><span class="p">,</span>
        <span class="s2">"&lt;&lt;"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">SHIFT</span><span class="p">,</span>
        <span class="s2">"&gt;&gt;"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">SHIFT</span><span class="p">,</span>
        <span class="s2">"|"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">BOR</span><span class="p">,</span>
        <span class="s2">"^"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">BXOR</span><span class="p">,</span>
        <span class="s2">"&amp;"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">BAND</span><span class="p">,</span>
        <span class="s2">"//"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">TERM</span><span class="p">,</span>
        <span class="s2">"**"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">POWER</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="n">binop_rassoc</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">((</span><span class="s2">"**"</span><span class="p">,))</span>
    <span class="k">def</span> <span class="nf">visit_BinOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
        <span class="n">operator_precedence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop_precedence</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">operator_precedence</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">operator</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">binop_rassoc</span><span class="p">:</span>
                <span class="n">left_precedence</span> <span class="o">=</span> <span class="n">operator_precedence</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
                <span class="n">right_precedence</span> <span class="o">=</span> <span class="n">operator_precedence</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">left_precedence</span> <span class="o">=</span> <span class="n">operator_precedence</span>
                <span class="n">right_precedence</span> <span class="o">=</span> <span class="n">operator_precedence</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">left_precedence</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s2"> "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">right_precedence</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>

    <span class="n">cmpops</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">"Eq"</span><span class="p">:</span> <span class="s2">"=="</span><span class="p">,</span>
        <span class="s2">"NotEq"</span><span class="p">:</span> <span class="s2">"!="</span><span class="p">,</span>
        <span class="s2">"Lt"</span><span class="p">:</span> <span class="s2">"&lt;"</span><span class="p">,</span>
        <span class="s2">"LtE"</span><span class="p">:</span> <span class="s2">"&lt;="</span><span class="p">,</span>
        <span class="s2">"Gt"</span><span class="p">:</span> <span class="s2">"&gt;"</span><span class="p">,</span>
        <span class="s2">"GtE"</span><span class="p">:</span> <span class="s2">"&gt;="</span><span class="p">,</span>
        <span class="s2">"Is"</span><span class="p">:</span> <span class="s2">"is"</span><span class="p">,</span>
        <span class="s2">"IsNot"</span><span class="p">:</span> <span class="s2">"is not"</span><span class="p">,</span>
        <span class="s2">"In"</span><span class="p">:</span> <span class="s2">"in"</span><span class="p">,</span>
        <span class="s2">"NotIn"</span><span class="p">:</span> <span class="s2">"not in"</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">def</span> <span class="nf">visit_Compare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">CMP</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">CMP</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">comparators</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">o</span><span class="p">,</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">ops</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">comparators</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmpops</span><span class="p">[</span><span class="n">o</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span> <span class="o">+</span> <span class="s2">" "</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="n">boolops</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"And"</span><span class="p">:</span> <span class="s2">"and"</span><span class="p">,</span> <span class="s2">"Or"</span><span class="p">:</span> <span class="s2">"or"</span><span class="p">}</span>
    <span class="n">boolop_precedence</span> <span class="o">=</span> <span class="p">{</span><span class="s2">"and"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">AND</span><span class="p">,</span> <span class="s2">"or"</span><span class="p">:</span> <span class="n">_Precedence</span><span class="o">.</span><span class="n">OR</span><span class="p">}</span>

    <span class="k">def</span> <span class="nf">visit_BoolOp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">operator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolops</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">op</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">]</span>
        <span class="n">operator_precedence</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">boolop_precedence</span><span class="p">[</span><span class="n">operator</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">increasing_level_traverse</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">operator_precedence</span>
            <span class="n">operator_precedence</span> <span class="o">=</span> <span class="n">operator_precedence</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">operator_precedence</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">operator_precedence</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">" </span><span class="si">{</span><span class="n">operator</span><span class="si">}</span><span class="s2"> "</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">increasing_level_traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="c1"># Special case: 3.__abs__() is a syntax error, so if node.value</span>
        <span class="c1"># is an integer literal then we need to either parenthesize</span>
        <span class="c1"># it or add an extra space to get 3 .__abs__().</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="n">Constant</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"."</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Call</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">func</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">):</span>
            <span class="n">comma</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">comma</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comma</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">keywords</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">comma</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comma</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Subscript</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">is_non_empty_tuple</span><span class="p">(</span><span class="n">slice_value</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="nb">isinstance</span><span class="p">(</span><span class="n">slice_value</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">)</span>
                <span class="ow">and</span> <span class="n">slice_value</span><span class="o">.</span><span class="n">elts</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"["</span><span class="p">,</span> <span class="s2">"]"</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_non_empty_tuple</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">slice</span><span class="p">):</span>
                <span class="c1"># parentheses can be omitted if the tuple isn't empty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">items_view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">slice</span><span class="o">.</span><span class="n">elts</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">slice</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Starred</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"*"</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">EXPR</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Ellipsis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"..."</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">lower</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">lower</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">":"</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">upper</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">upper</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">step</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">":"</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Match</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"match "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">subject</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">case</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">cases</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">case</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_arg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">": "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">first</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># normal arguments</span>
        <span class="n">all_args</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">posonlyargs</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">args</span>
        <span class="n">defaults</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_args</span><span class="p">)</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">defaults</span><span class="p">))</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">defaults</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">elements</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">all_args</span><span class="p">,</span> <span class="n">defaults</span><span class="p">),</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">elements</span>
            <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"="</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">posonlyargs</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", /"</span><span class="p">)</span>

        <span class="c1"># varargs, or bare '*' if no varargs but keyword-only arguments present</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">vararg</span> <span class="ow">or</span> <span class="n">node</span><span class="o">.</span><span class="n">kwonlyargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"*"</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">vararg</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">vararg</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">vararg</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">": "</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">vararg</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>

        <span class="c1"># keyword-only arguments</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">kwonlyargs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kwonlyargs</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">kw_defaults</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"="</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># kwargs</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">kwarg</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">first</span><span class="p">:</span>
                <span class="n">first</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"**"</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">kwarg</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">kwarg</span><span class="o">.</span><span class="n">annotation</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">": "</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">kwarg</span><span class="o">.</span><span class="n">annotation</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_keyword</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">arg</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"**"</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">arg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"="</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_Lambda</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"lambda"</span><span class="p">)</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffered</span><span class="p">()</span> <span class="k">as</span> <span class="n">buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">args</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">buffer</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" "</span><span class="p">,</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">": "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_alias</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">asname</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" as "</span> <span class="o">+</span> <span class="n">node</span><span class="o">.</span><span class="n">asname</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_withitem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">context_expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">optional_vars</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" as "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">optional_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_match_case</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="s2">"case "</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node</span><span class="o">.</span><span class="n">guard</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" if "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">guard</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">block</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">body</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_MatchValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_MatchSingleton</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_write_constant</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_MatchSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"["</span><span class="p">,</span> <span class="s2">"]"</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span>
                <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">patterns</span>
            <span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_MatchStar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">"_"</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">"*</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_MatchMapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">write_key_pattern_pair</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
            <span class="n">k</span><span class="p">,</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pair</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">": "</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"{"</span><span class="p">,</span> <span class="s2">"}"</span><span class="p">):</span>
            <span class="n">keys</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">keys</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span>
                <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span>
                <span class="n">write_key_pattern_pair</span><span class="p">,</span>
                <span class="nb">zip</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">patterns</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="n">rest</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">rest</span>
            <span class="k">if</span> <span class="n">rest</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">"**</span><span class="si">{</span><span class="n">rest</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_MatchClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">ATOM</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">cls</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">cls</span><span class="p">)</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">delimit</span><span class="p">(</span><span class="s2">"("</span><span class="p">,</span> <span class="s2">")"</span><span class="p">):</span>
            <span class="n">patterns</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">patterns</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span>
                <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">patterns</span>
            <span class="p">)</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">kwd_attrs</span>
            <span class="k">if</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">write_attr_pattern</span><span class="p">(</span><span class="n">pair</span><span class="p">):</span>
                    <span class="n">attr</span><span class="p">,</span> <span class="n">pattern</span> <span class="o">=</span> <span class="n">pair</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">attr</span><span class="si">}</span><span class="s2">="</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">pattern</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">patterns</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span>
                    <span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">", "</span><span class="p">),</span>
                    <span class="n">write_attr_pattern</span><span class="p">,</span>
                    <span class="nb">zip</span><span class="p">(</span><span class="n">attrs</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">kwd_patterns</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_MatchAs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">name</span>
        <span class="n">pattern</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">pattern</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">"_"</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">pattern</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">TEST</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">BOR</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">pattern</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="sa">f</span><span class="s2">" as </span><span class="si">{</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">visit_MatchOr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">require_parens</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">BOR</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_precedence</span><span class="p">(</span><span class="n">_Precedence</span><span class="o">.</span><span class="n">BOR</span><span class="o">.</span><span class="n">next</span><span class="p">(),</span> <span class="o">*</span><span class="n">node</span><span class="o">.</span><span class="n">patterns</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">interleave</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">" | "</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse</span><span class="p">,</span> <span class="n">node</span><span class="o">.</span><span class="n">patterns</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unparse</span><span class="p">(</span><span class="n">ast_obj</span><span class="p">):</span>
    <span class="n">unparser</span> <span class="o">=</span> <span class="n">_Unparser</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">unparser</span><span class="o">.</span><span class="n">visit</span><span class="p">(</span><span class="n">ast_obj</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">argparse</span>

    <span class="n">parser</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">prog</span><span class="o">=</span><span class="s1">'python -m ast'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'infile'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">FileType</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s1">'rb'</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">'?'</span><span class="p">,</span>
                        <span class="n">default</span><span class="o">=</span><span class="s1">'-'</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">'the file to parse; defaults to stdin'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-m'</span><span class="p">,</span> <span class="s1">'--mode'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">'exec'</span><span class="p">,</span>
                        <span class="n">choices</span><span class="o">=</span><span class="p">(</span><span class="s1">'exec'</span><span class="p">,</span> <span class="s1">'single'</span><span class="p">,</span> <span class="s1">'eval'</span><span class="p">,</span> <span class="s1">'func_type'</span><span class="p">),</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">'specify what kind of code must be parsed'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'--no-type-comments'</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_false'</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">"don't add information about type comments"</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-a'</span><span class="p">,</span> <span class="s1">'--include-attributes'</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">'store_true'</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">'include attributes such as line numbers and '</span>
                             <span class="s1">'column offsets'</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">'-i'</span><span class="p">,</span> <span class="s1">'--indent'</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">int</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                        <span class="n">help</span><span class="o">=</span><span class="s1">'indentation of nodes (number of spaces)'</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>

    <span class="k">with</span> <span class="n">args</span><span class="o">.</span><span class="n">infile</span> <span class="k">as</span> <span class="n">infile</span><span class="p">:</span>
        <span class="n">source</span> <span class="o">=</span> <span class="n">infile</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">parse</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">infile</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">.</span><span class="n">mode</span><span class="p">,</span> <span class="n">type_comments</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">no_type_comments</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">dump</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">include_attributes</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">include_attributes</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">indent</span><span class="p">))</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</article>
</div>
</div>
<footer class="bd-footer-content">
</footer>
</main>
</div>
</div>
<!-- Scripts loaded after <body> so the DOM is not blocked -->
<script src="../_static/scripts/bootstrap.js?digest=dfe6caa3a7d634c4db9b"></script>
<script src="../_static/scripts/pydata-sphinx-theme.js?digest=dfe6caa3a7d634c4db9b"></script>
<footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">
<div class="footer-items__start">
<div class="footer-item">
<p class="copyright">
    
      Â© Copyright 2023, LangChain Inc.
      <br/>
</p>
</div>
</div>
</div>
</footer>
</body>
</html>